---
title: "TMEM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TMEM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Package Install {.tabset .tabset-pills .tabset-fade}

### **Install TMEM Package from GitHub**

Install the package from `github`

```{r Github install package, include = T, eval = F, warning = F, message = F, echo = T}
devtools::install_github('https://github.com/eriklarsen4/TMEM')
```

### **Install TMEM Package from CRAN**

Alternatively, if the package is accepted by CRAN, install from CRAN

```{r CRAN install TMEM package, include = T, eval = F, warning = F, message = F, echo = T}
utils::install.packages('TMEM')
```

```{r Local install for dev, include = F, eval = F, warning = F, message = F, echo = F}
devtools::install_local('C:/Users/Erik/Desktop/Programming/R/Bio/TMEM/TMEM_1.0.0.zip')
devtools::install('C:/Users/Erik/Desktop/Programming/R/Bio/TMEM', dependencies = 'Imports')
library(TMEM)
devtools::load_all()
```


### **Attach TMEM Package**

```{r Attach package, include = T, warning = F, message = F, echo = T}
library(TMEM)
devtools::load_all()
```

We'll use the datasets included in the `TMEM` package to demonstrate its functions.

## Functions {.tabset .tabset-pills .tabset-fade}

### **GO_INFO_fn**

After installing and attaching the `TMEM` package, one of its crucial functions is
the `GO_INFO_fn` that gathers all the gene ontology information of a list of gene
or protein identifiers

This is what is called **gene set enrichment analysis (GSEA)**

The `GSEA` conducted on this dataset is included in full in [a markdown of another repository](https://github.com/eriklarsen4/Itch/blob/main/Code/GSEA/ItchGSEA.md),
along with additional analyses for [that paper](https://pmc.ncbi.nlm.nih.gov/articles/PMC8854445/#_ad93_)

The real utility of the function is gathering all the relevant information in one
place without needing to generate multiple files and analyses in a browser-- it's
all in-house

However, this `GSEA` utilizes `Bioconductor`'s **AnnotationDbi** package, thus, there are discrepancies
with, for example, `geneontology.org`'s annotations

`Bioconductor` also does not employ `geneontology.org`'s gene ontology (nesting) structure,
which effects any statistics a user might try to extract

I suggest using this function for exploratory work and plotting, while relying on
`geneontology.org`'s [web browser](https://geneontology.org/) directly for publications-- I've
noticed differences between `GO.db R package` results and those from the browser.

The statistical discrepancies are noted in the examples section of this vignette

```{r GO_INFO_fn call, include = T, warning = F, message = F, echo = T}
## First import the data in the package
data("aDRG_DEG_list")

## pass the variable into the function (data was derived from mouse)
results <- TMEM::GO_INFO_fn(list_of_interest = aDRG_DEG_list, species = 'mouse')
```

Inspect results by unpacking everything from the returned list

```{r GO_INFO_results, include = T, message = F, warning = F, echo = T}
  ## GO INFO about each Unique GO returned by the list
GO_INFO_by_TERM_df <- results |> 
  purrr::keep_at("GO_INFO_by_TERM_df") |> 
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'GO_INFO_by_TERM_df\\.', replacement = ''))

  ## GO INFO about each gene in the list
GENE_GO_INFO_df <- results |> 
  purrr::keep_at("GENE_GO_INFO_df") |>
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'GENE_GO_INFO_df\\.', replacement = ''))

  ## every alias for each gene in the list
aliases <- results |> 
  purrr::keep_at("aliases")

  ## all aliases from the list without the genes of the list
list_of_interest_aliases <- results |> 
  purrr::keep_at("list_of_interest_aliases") |>
  unlist() |> 
  as.character()

  ## Unique GOs returned by the list
Unique_GOs <- results |> 
  purrr::keep_at("Unique_GOs")

  ## Unique GO IDs returned by the list
Unique_GO_IDs <- results |> 
  purrr::keep_at("Unique_GO_IDs")
```

Print the `GO_INFO_by_TERM_df` to the console

```{r Show GO_INFO_df, include = T, message = F, warning = F, echo = T}
head(GO_INFO_by_TERM_df)
```

### **ortholog_and_alias_fn**

Pass the gene list to the `ortholog_and_alias_fn`

Since the data is derived from `mouse`, `mouse` will serve as the `ref_species`

```{r Ortholog_and_alias_fn call, include = T, message = F, warning = F, echo = T}
ortholog_df <- TMEM::ortholog_and_alias_fn(ref_species = 'mouse', list_of_interest = aDRG_DEG_list)
```

Print the `ortholog_and_alias_fn` output to console

```{r Show ortholog results, include = T, message = F, warning = F, echo = T}
head(ortholog_df)
```

It may be very useful to pass the list of genes with their aliases 
(c(`list_of_interest_aliases`, `aDRG_DEG_list`)) to the `GO_INFO_fn`

### **Query_GO_fn**

Another useful function with multiple uses is finding genes/proteins annotated 
to certain `GO Terms`

This can be useful for:
+ investigating molecular pathways
+ investigating complexes (for cross-checking or discovery)
+ finding multiple `GO Terms` that contain a regular expression string

```{r Query_GO_fn call, include = T, message = F, warning = F, echo = T}
TMEM::Query_GO_fn(model_org = 'human', GO_db = GO.db::GO.db, string_terms = 'dense core vesicle|lysosome')
```

Extracting the gene/protein IDs associated with the `GO Terms` derived from the given
regular expression(s) is non-trivial, depending on the function call.

Those gene/protein IDs associated with a given term can be extracted directly using
`dplyr` without storing all the function's results to an object in the global environment: 
  
```{r Query_GO_fn dplyr extraction, include = T, message = F, warning = F, echo = T}
TMEM::Query_GO_fn(model_org = 'human', GO_db = GO.db::GO.db, string_terms = 'dense core vesicle|lysosome') |> 
  purrr::keep_at("GO_df") |> 
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'GO_df.', replacement = '')) %>%
  dplyr::rename_with(., ~gsub(.x, pattern = '\\.\\.', replacement = 'N.')) |>
  dplyr::filter(GO.Term == 'endolysosome membrane') |> 
  dplyr::select(Genes) |> 
  unlist() |> 
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
```

Alternatively, all of the results can be stored to an object in the global
environment from which (in this example) the gene/protein IDs can be extracted:
  
```{r Query_GO_fn extraction, include = T, message = F, warning = F, echo = T}
query_GO_results <- TMEM::Query_GO_fn(model_org = 'human', GO_db = GO.db::GO.db, string_terms = 'dense core vesicle|lysosome')
  
query_GO_results$GO_df |> 
  dplyr::filter(`GO Term` == 'endolysosome membrane') |> 
  dplyr::select(Genes) |> 
  unlist() |> 
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
```

### **Find_Row_Z**

This function computes a Z-score for a provided matrix, currently agnostic to 
grouping

This is highly useful for generating transcriptional heatmaps

```{r Find_Row_Z call, include = T, message = F, warning = F, echo = T}
TMEM::Find_Row_Z(Expression_Profile = data("aDRG_TPM"))
```


## Example Uses {.tabset .tabset-pills .tabset-fade}

### **Finding Genes Related by a Generic GO Term relevant to a list of interest**

Interested in finding out what has been documented to be related to a certain
cellular phenomenon?

When there are multiple terms involving a certain phrase (i.e. organelles or processes),
simply searching GO terms using regular expressions is an effective approach

Obviously, this provides larger scope than investigating a specific term

```{r Find_Genes_Related_By_Generic_GO_Term, include = T, warning = F, message = F, echo = T}
GO_INFO_by_TERM_df |> 
  dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  unique()
```

Similarly, the results returned by the `GO_INFO_fn` include all the information
on all the `GO Term`s-- not just including the genes/proteins from the list of interest
that are associated with a `GO Term` (these IDs are called "`Overlap`"); it provides
*all* the IDs associated with the `GO Term`

```{r Find_All_Genes_Related_By_Generic_GO_Term, include = T, warning = F, message = F, echo = T}
GO_INFO_by_TERM_df |> 
  dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
  dplyr::select(Gene_IDs) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  unique()
```

Lastly, to find those IDs across generic GO Terms **NOT** also in the provided list
of IDs:

```{r Find_Genes_Not_in_List_Across_GO_Terms, include = T, warning = F, message = F, echo = T}
"%notin%" <- Negate("%in%")

c(GO_INFO_by_TERM_df |> 
    dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
    dplyr::select(Gene_IDs) |>
    unlist() |> 
    as.character() %>%
    paste0(., collapse = ';') %>%
    stringr::str_split_1(., pattern = ';') |> 
    unique() # All the genes in all the GO Terms
  )[
    which(
  c(GO_INFO_by_TERM_df |> 
      dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
      dplyr::select(Gene_IDs) |>
      unlist() |> 
      as.character() %>%
      paste0(., collapse = ';') %>%
      stringr::str_split_1(., pattern = ';') |> 
      unique()
  ) %notin%
  c(GO_INFO_by_TERM_df |>
      dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
      dplyr::select(Gene_IDs_from_List) |> 
      unlist() |> 
      as.character() %>%
      paste0(., collapse = ';') %>% 
      stringr::str_split_1(., pattern = ';') |> 
      unique() ) == T
)
] # All the genes in all the GO Terms indexed by those that are NOT in the list 
    # of interest
```

### **Finding Genes Related by Multiple Precise GO Terms**

Interested in which genes from your list of interest overlap across multiple `GO Term`s elicited by your 
query/list of interest?

```{r Find_Genes_Related_By_GO_Terms, include = T, message = F, warning = F, echo = T}
c(GO_INFO_by_TERM_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle' |
                  GO_Term == 'growth') |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';')%>%
  stringr::str_split_1(., pattern = ';'))[which(GO_INFO_by_TERM_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle' |
                  GO_Term == 'growth'
                ) |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |>
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  duplicated() == T
)]

```

### **Finding GO of Any Number of Genes**

When a user is interested in all of the `Go Terms` that are shared by multiple
gene/protein IDs from the user's list of gene/protein IDs:

```{r Find_GOs_of_Muliple_Genes, include = T, message = F, warning = F, echo = T}
head(GENE_GO_INFO_df |> 
  dplyr::filter(GeneID == 'Lpar3' |
                  GeneID == 'Lpar5') |>
  dplyr::select(GO_Terms) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |>
  unique()
  )
```

Similarly, repeating the above for just one gene/protein is simpler-- remove the
`|` and subsequent `GeneID`s:

```{r Find_All_GOs_of_One_Gene, include = T, message = F, warning = F, echo = T}
head(GENE_GO_INFO_df |>
  dplyr::filter(GeneID == 'Il31ra') |> 
  dplyr::select(GO_Terms) |> 
  unlist() |>
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
  )
```

### **Finding Genes of a Specific GO Term**

```{r Finding_Genes_of_a_Specific_GO_Term, include = T, warning = F, message = F, echo = T}
head(GO_INFO_by_TERM_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle') |> 
  dplyr::select(Gene_IDs) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';')
)
```


### **Finding Enriched GOs from the GO_INFO_fn**

Determining which `GO`s (themes) are worth looking into further is the entire
point of `GSEA`

The `GO_INFO_fn` returns all the `GO Terms` relevant to a user's provided list, and
does not include all annotated `GO Terms`

The function also relies on `Bioconductor`'s species-specific databases, as well as
its own version of the `GO.db`'s annotations (which may, *themselves* differ from
annotations on the `geneontology.org` website)

Thus, there are discrepancies in which genes map to which terms, and in the adaptation
of [PANTHER](https://pantherdb.org/tools/)'s
(via [geneontology.org](https://geneontology.org/)) statistical methods

In brief, `PANTHER` permits the computation of a binomial test statistic or, via
Fisher's exact test, the probability of (in this case) observing at least the
number of gene/protein IDs (or more) from the submitted list in a given `GO Term`

`PANTHER` provides corresponding adjusted p-values via the `Benjamini-Hochberg Method`
for each statistic (Fisher's p-value, binomial test statistic's p-value)

See below examples of this

```{r Find_Enriched_GOs setup, include = T, message = F, warning = F, echo = T}

Genes_in_Human_Genome <- 23481
Genes_in_Mouse_Genome <- 54879

# note that there are 21836 uniquely mapped genes

GO_INFO_by_TERM_df2 <- GO_INFO_by_TERM_df |> 
  dplyr::arrange(desc(Overlap)) |> 
  dplyr::mutate(Term_Freq = GO_Term_Size/Genes_in_Mouse_Genome,
                Expected = length(aDRG_DEG_list) * Term_Freq,
                FE = Overlap/Expected) |> 
  dplyr::filter(!is.na(GO_Term))

```

Compute the p-values according to `PANTHER`'s documentation

```{r PANTHERs pval method, include = T, warning = F, message = F, echo = T}
for (i in 1:nrow(GO_INFO_by_TERM_df2)) {
  
  # compute p-value for binomial test statistic according to PANTHER's documentation
  
    if (GO_INFO_by_TERM_df2$Overlap[i] > GO_INFO_by_TERM_df2$Expected[i]) { # for over-representation
    GO_INFO_by_TERM_df2$pval[i] <- sum(
      (GO_INFO_by_TERM_df2$Term_Freq[i]^(seq(GO_INFO_by_TERM_df2$Overlap[i],
                                             length(aDRG_DEG_list))
                                         ))*(1 - GO_INFO_by_TERM_df2$Term_Freq[i])^(seq(length(aDRG_DEG_list)-GO_INFO_by_TERM_df2$Overlap[i],
                                                                                      0
                                                                                     )
                                                                                 )
    )
    } else { # for under-representation
    GO_INFO_by_TERM_df2$pval[i] <- sum(
      ((GO_INFO_by_TERM_df2$Term_Freq[i])^(seq(0,GO_INFO_by_TERM_df2$Overlap[i])
                                         ))*(1 - GO_INFO_by_TERM_df2$Term_Freq[i])^(seq(length(aDRG_DEG_list),
                                                                                      GO_INFO_by_TERM_df2$Overlap[i]
                                                                                     
                                                                                     )
                                                                                 )
    )
    }
}

```

Compute p-values using `rstatix`'s binomial test for both `df`s

```{r rstatixs pval method, include = T, warning = F, message = F, echo = T}

GO_INFO_by_TERM_df2$binom_pval = NA_real_

for (i in 1:nrow(GO_INFO_by_TERM_df2)) {
  GO_INFO_by_TERM_df2$binom_pval[i] = rstatix::binom_test(
    x = c(GO_INFO_by_TERM_df2$Overlap[i],
          GO_INFO_by_TERM_df2$GO_Term_Size[i]-GO_INFO_by_TERM_df2$Overlap[i]),
    p = (GO_INFO_by_TERM_df2$GO_Term_Size[i]/Genes_in_Mouse_Genome),
    alternative = 'two.sided',
    conf.level = 0.95,
    detailed = TRUE) |> 
    dplyr::select(p) |> unlist() |> as.character() |> as.numeric()
}

```

Add Adjusted P-values using BHM

Note these, and all p-values do not match those from all the same results from
the `geneontology.org` website

```{r Add AdjP, include = T, message = F, warning = F, echo = T}

GO_INFO_by_TERM_df2$binom_adjp = NA_real_

for (i in 1:nrow(GO_INFO_by_TERM_df2)) {
  GO_INFO_by_TERM_df2$binom_adjp[i] = rstatix::binom_test(
    x = c(GO_INFO_by_TERM_df2$Overlap[i],
          GO_INFO_by_TERM_df2$GO_Term_Size[i]-GO_INFO_by_TERM_df2$Overlap[i]),
    p = (GO_INFO_by_TERM_df2$GO_Term_Size[i]/Genes_in_Mouse_Genome),
    alternative = 'two.sided',
    conf.level = 0.95,
    detailed = TRUE) |> 
    dplyr::select(p) |> unlist() |> as.character() |> as.numeric()
}

GO_INFO_by_TERM_df2 <- GO_INFO_by_TERM_df2 |> 
  dplyr::mutate(adjp = p.adjust(p = GO_INFO_by_TERM_df2$pval, method = 'BH'), .after= pval)

GO_INFO_by_TERM_df2$binom_adjp = p.adjust(p = GO_INFO_by_TERM_df2$binom_pval, method = 'BH')
```

