---
title: "TMEM"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{TMEM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Package Install {.tabset .tabset-pills .tabset-fade}

### **Install TMEM Package from GitHub**

Install the package from `github`

```{r Github install package, include = T, eval = F, warning = F, message = F, echo = T}
devtools::install_github('https://github.com/eriklarsen4/TMEM')
```

### **Install TMEM Package from CRAN**

Alternatively, if the package is accepted by CRAN, install from CRAN

```{r CRAN install TMEM package, include = T, eval = F, warning = F, message = F, echo = T}
utils::install.packages('TMEM')
```

```{r Local install for dev, include = F, eval = F, warning = F, message = F, echo = F}
devtools::install_local('C:/Users/Erik/Desktop/Programming/R/Bio/TMEM/TMEM_1.0.0.zip')
devtools::install('C:/Users/Erik/Desktop/Programming/R/Bio/TMEM', dependencies = 'Imports')
library(TMEM)
devtools::load_all()
```


### **Attach TMEM Package**

```{r Attach package, include = T, warning = F, message = F, echo = T}
library(TMEM)
devtools::load_all()
```

We'll use the datasets included in the `TMEM` package to demonstrate its functions.

## Functions {.tabset .tabset-pills .tabset-fade}

### **get_GO_info**

After installing and attaching the `TMEM` package, one of its crucial functions
is the `get_GO_info` that gathers all the gene ontology information of a list of
gene or protein identifiers

This is called **gene set enrichment analysis (GSEA)**

The `GSEA` conducted on this dataset is included in full in
[a markdown of another repository](https://github.com/eriklarsen4/Itch/blob/main/Code/GSEA/ItchGSEA.md),
along with additional analyses for [that paper](https://pmc.ncbi.nlm.nih.gov/articles/PMC8854445/#_ad93_)

There, we used the statistical results directly from the `geneontology.org`
website

The real utility of the `get_GO_info` function is in gathering all the relevant
information in one place without needing to generate multiple files and analyses
across one or more browsers-- it's all in-house

However, because this function utilizes `Bioconductor`'s **AnnotationDbi** and
**GO.db** packages, there are (unsurprisingly) discrepancies between
`geneontology.org`'s annotations and `Bioconductor`'s. Furthermore,
`Bioconductor` does not employ `geneontology.org`'s gene ontology nesting
structure (see the vignette), which effects statistics (also not provided by
`Bioconductor`) a user might try to extract

Thus, for now, I recommend using the `get_GO_info` function for exploratory work
and plotting, while relying on `geneontology.org`'s
[web browser](https://geneontology.org/) directly for publications

The statistical discrepancies are noted in the examples section of this markdown

```{r get_GO_info call, include = T, warning = F, message = F, echo = T}
## First import the data in the package
data("aDRG_DEG_list")

## pass the variable into the function (data was derived from mouse)
results <- TMEM::get_GO_info(list_of_interest = aDRG_DEG_list, species = 'mouse')
```

Inspect results by unpacking everything from the returned list

```{r GO_INFO_results, include = T, message = F, warning = F, echo = T}
  ## GO INFO about each Unique GO returned by the list
GO_info_by_term_df <- results |> 
  purrr::keep_at("GO_info_by_term_df") |> 
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'GO_info_by_term_df\\.', replacement = ''))

  ## GO INFO about each gene in the list
gene_GO_info_df <- results |> 
  purrr::keep_at("gene_GO_info_df") |>
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'gene_GO_info_df\\.', replacement = ''))

  ## every alias for each gene in the list
aliases <- results |> 
  purrr::keep_at("aliases")

  ## all aliases from the list without the genes of the list
list_of_interest_aliases <- results |> 
  purrr::keep_at("list_of_interest_aliases") |>
  unlist() |> 
  as.character()

  ## Unique GOs returned by the list
unique_GOs <- results |> 
  purrr::keep_at("unique_GOs")

  ## Unique GO IDs returned by the list
unique_GO_IDs <- results |> 
  purrr::keep_at("unique_GO_IDs")
```

Print the `GO_info_by_term_df` to the console

```{r Show GO_info_df, include = T, message = F, warning = F, echo = T}
head(GO_info_by_term_df)
```

### **get_orthologs_and_aliases**

#### Example

Pass the gene list to the `get_orthologs_and_aliases`

Since the data is derived from `mouse`, `mouse` will serve as the `ref_species`

```{r get_orthologs_and_aliases call, include = T, message = F, warning = F, echo = T}
ortholog_df <- TMEM::get_orthologs_and_aliases(ref_species = 'mouse',
                                               list_of_interest = aDRG_DEG_list)
```

Print the `ortholog_and_alias_fn` output to console

```{r Show ortholog results, include = T, message = F, warning = F, echo = T}
head(ortholog_df)
```

It may be very useful to pass the list of genes with their aliases 
(c(`list_of_interest_aliases`, `aDRG_DEG_list`)) to the `get_GO_info` function

### **query_GO**

#### Background

Another useful function with multiple uses is finding genes/proteins annotated 
to certain `GO Terms`

This can be useful for:
+ investigating molecular pathways
+ investigating complexes (for cross-checking or discovery)
+ finding multiple `GO Terms` that contain a regular expression string

#### Example

```{r query_GO fn call, include = T, message = F, warning = F, echo = T}
TMEM::query_GO(model_org = 'human', string_terms = 'dense core vesicle|lysosome')
```

Extracting the gene/protein IDs associated with the `GO Terms` derived from the given
regular expression(s) is non-trivial, depending on the function call.

Those gene/protein IDs associated with a given term can be extracted directly using
`dplyr` without storing all the function's results to an object in the global environment: 
  
```{r query_GO fn dplyr extraction, include = T, message = F, warning = F, echo = T}
TMEM::query_GO(model_org = 'human', string_terms = 'dense core vesicle|lysosome') |> 
  purrr::keep_at("GO_df") |> 
  as.data.frame() %>%
  dplyr::rename_with(., ~gsub(.x, pattern = 'GO_df.', replacement = '')) %>%
  dplyr::rename_with(., ~gsub(.x, pattern = '\\.\\.', replacement = 'N.')) |>
  dplyr::filter(GO.Term == 'endolysosome membrane') |> 
  dplyr::select(Genes) |> 
  unlist() |> 
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
```

Alternatively, all of the results can be stored to an object in the global
environment from which (in this example) the gene/protein IDs can be extracted:
  
```{r query_GO fn extraction, include = T, message = F, warning = F, echo = T}
query_GO_results <- TMEM::query_GO(model_org = 'human',
                                   string_terms = 'dense core vesicle|lysosome')
  
query_GO_results$GO_df |> 
  dplyr::filter(`GO Term` == 'endolysosome membrane') |> 
  dplyr::select(Genes) |> 
  unlist() |> 
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
```

### **find_row_Z**

#### Background

This function computes a Z-score for a provided matrix, currently agnostic to 
grouping

This is highly useful for generating transcriptional heatmaps

#### Example

```{r find_row_Z call, include = T, message = F, warning = F, echo = T}
data("aDRG_TPM")
TMEM::find_row_Z(Expression_Profile = aDRG_TPM)
```


## Example Uses {.tabset .tabset-pills .tabset-fade}

### **Finding Genes Related by a Generic GO Term relevant to a list of interest**

Interested in finding out what has been documented to be related to a certain
cellular phenomenon?

When there are multiple terms involving a certain phrase (i.e. organelles or processes),
simply searching GO terms using regular expressions is an effective approach

Obviously, this provides larger scope than investigating a specific term

```{r Find_Genes_Related_By_Generic_GO_Term, include = T, warning = F, message = F, echo = T}
GO_info_by_term_df |> 
  dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  unique()
```

Similarly, the results returned by the `get_GO_info` function include all the information
on all the `GO Term`s-- not just including the genes/proteins from the list of interest
that are associated with a `GO Term` (these IDs are called "`Overlap`"); it provides
*all* the IDs associated with the `GO Term`

```{r Find_All_Genes_Related_By_Generic_GO_Term, include = T, warning = F, message = F, echo = T}
GO_info_by_term_df |> 
  dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
  dplyr::select(Gene_IDs) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  unique()
```

Lastly, to find those IDs across generic GO Terms **NOT** also in the provided list
of IDs:

```{r Find_Genes_Not_in_List_Across_GO_Terms, include = T, warning = F, message = F, echo = T}
"%notin%" <- Negate("%in%")

c(GO_info_by_term_df |> 
    dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
    dplyr::select(Gene_IDs) |>
    unlist() |> 
    as.character() %>%
    paste0(., collapse = ';') %>%
    stringr::str_split_1(., pattern = ';') |> 
    unique() # All the genes in all the GO Terms
  )[
    which(
  c(GO_info_by_term_df |> 
      dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
      dplyr::select(Gene_IDs) |>
      unlist() |> 
      as.character() %>%
      paste0(., collapse = ';') %>%
      stringr::str_split_1(., pattern = ';') |> 
      unique()
  ) %notin%
  c(GO_info_by_term_df |>
      dplyr::filter(grepl(GO_Term, pattern = 'dense core vesicle')) |> 
      dplyr::select(Gene_IDs_from_List) |> 
      unlist() |> 
      as.character() %>%
      paste0(., collapse = ';') %>% 
      stringr::str_split_1(., pattern = ';') |> 
      unique() ) == T
)
] # All the genes in all the GO Terms indexed by those that are NOT in the list 
    # of interest
```

### **Finding Genes Related by Multiple Precise GO Terms**

Interested in which genes from your list of interest overlap across multiple `GO Term`s elicited by your 
query/list of interest?

```{r Find_Genes_Related_By_GO_Terms, include = T, message = F, warning = F, echo = T}
c(GO_info_by_term_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle' |
                  GO_Term == 'growth') |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';')%>%
  stringr::str_split_1(., pattern = ';'))[which(GO_info_by_term_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle' |
                  GO_Term == 'growth'
                ) |> 
  dplyr::select(Gene_IDs_from_List) |> 
  unlist() |>
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |> 
  duplicated() == T
)]

```

### **Finding GO of Any Number of Genes**

When a user is interested in all of the `Go Terms` that are shared by multiple
gene/protein IDs from the user's list of gene/protein IDs:

```{r Find_GOs_of_Muliple_Genes, include = T, message = F, warning = F, echo = T}
head(gene_GO_info_df |> 
  dplyr::filter(GeneID == 'Lpar3' |
                  GeneID == 'Lpar5') |>
  dplyr::select(GO_Terms) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';') |>
  unique()
  )
```

Similarly, repeating the above for just one gene/protein is simpler-- remove the
`|` and subsequent `GeneID`s:

```{r Find_All_GOs_of_One_Gene, include = T, message = F, warning = F, echo = T}
head(gene_GO_info_df |>
  dplyr::filter(GeneID == 'Il31ra') |> 
  dplyr::select(GO_Terms) |> 
  unlist() |>
  as.character() %>%
  stringr::str_split_1(., pattern = ';')
  )
```

### **Finding Genes of a Specific GO Term**

```{r Finding_Genes_of_a_Specific_GO_Term, include = T, warning = F, message = F, echo = T}
head(GO_info_by_term_df |> 
  dplyr::filter(GO_Term == 'neuronal dense core vesicle') |> 
  dplyr::select(Gene_IDs) |> 
  unlist() |> 
  as.character() %>%
  paste0(., collapse = ';') %>%
  stringr::str_split_1(., pattern = ';')
)
```


### **Finding Enriched GOs from the get_GO_info function**

Determining which `GO`s (themes) are worth looking into further is the entire
point of `GSEA`

The `get_GO_info` function returns all the `GO Terms` relevant to a user's
provided list, and does not include all annotated `GO Terms`

As described in the **get_GO_info Background** section above, there are
discrepancies between `Bioconductor`'s R packages and the `geneontology.org`
website in terms of their annotations, which effect statistical inference

Below, I derive enrichment according to `PANTHER`'s
[documentation](https://pantherdb.org/tips/tips_overrep.jsp) and perform
its subsequent statistical test with FDR correction and compare these results to
the image from the `geneontology.org` website:

In brief, `PANTHER` (`geneontology.org`) permits the computation of a
binomial test statistic or, via Fisher's exact test, the probability of 
in this case) observing at least the number of gene/protein IDs (or more) from
the submitted list in a given `GO Term`

`PANTHER` provides corresponding adjusted p-values via the
`Benjamini-Hochberg Method` for each statistic (Fisher's p-value, binomial test
statistic's p-value)

```{r Find_Enriched_GOs setup, include = T, message = F, warning = F, echo = T}

Genes_in_Human_Genome <- 23481
Genes_in_Mouse_Genome <- 54879

# note that there are 21836 uniquely mapped genes

GO_info_by_term_df2 <- GO_info_by_term_df |> 
  dplyr::arrange(desc(Overlap)) |> 
  dplyr::mutate(Term_Freq = GO_Term_Size/Genes_in_Mouse_Genome,
                Expected = length(aDRG_DEG_list) * Term_Freq,
                FE = Overlap/Expected) |> 
  dplyr::filter(!is.na(GO_Term))

```

Compute the p-values according to `PANTHER`'s documentation

```{r PANTHERs pval method, include = T, warning = F, message = F, echo = T}
for (i in 1:nrow(GO_info_by_term_df2)) {
  
  # compute p-value for binomial test statistic according to PANTHER's documentation
  
    if (GO_info_by_term_df2$Overlap[i] > GO_info_by_term_df2$Expected[i]) { # for over-representation
    GO_info_by_term_df2$pval[i] <- sum(
      (GO_info_by_term_df2$Term_Freq[i]^(seq(GO_info_by_term_df2$Overlap[i],
                                             length(aDRG_DEG_list))
                                         ))*(1 - GO_info_by_term_df2$Term_Freq[i])^(seq(length(aDRG_DEG_list)-GO_info_by_term_df2$Overlap[i],
                                                                                      0
                                                                                     )
                                                                                 )
    )
    } else { # for under-representation
    GO_info_by_term_df2$pval[i] <- sum(
      ((GO_info_by_term_df2$Term_Freq[i])^(seq(0,GO_info_by_term_df2$Overlap[i])
                                         ))*(1 - GO_info_by_term_df2$Term_Freq[i])^(seq(length(aDRG_DEG_list),
                                                                                      GO_info_by_term_df2$Overlap[i]
                                                                                     
                                                                                     )
                                                                                 )
    )
    }
}

```

Compute p-values using `rstatix`'s binomial test for both `df`s

```{r rstatixs pval method, include = T, warning = F, message = F, echo = T}

GO_info_by_term_df2$binom_pval = NA_real_

for (i in 1:nrow(GO_info_by_term_df2)) {
  GO_info_by_term_df2$binom_pval[i] = rstatix::binom_test(
    x = c(GO_info_by_term_df2$Overlap[i],
          GO_info_by_term_df2$GO_Term_Size[i]-GO_info_by_term_df2$Overlap[i]),
    p = (GO_info_by_term_df2$GO_Term_Size[i]/Genes_in_Mouse_Genome),
    alternative = 'two.sided',
    conf.level = 0.95,
    detailed = TRUE) |> 
    dplyr::select(p) |> unlist() |> as.character() |> as.numeric()
}

```

Add Adjusted P-values using BHM

Note these, and all p-values do not match those from all the same results from
the `geneontology.org` website (the image in the `get_GO_info` function 
**Background** section)

```{r Add AdjP, include = T, message = F, warning = F, echo = T}

GO_info_by_term_df2$binom_adjp = NA_real_

for (i in 1:nrow(GO_info_by_term_df2)) {
  GO_info_by_term_df2$binom_adjp[i] = rstatix::binom_test(
    x = c(GO_info_by_term_df2$Overlap[i],
          GO_info_by_term_df2$GO_Term_Size[i]-GO_info_by_term_df2$Overlap[i]),
    p = (GO_info_by_term_df2$GO_Term_Size[i]/Genes_in_Mouse_Genome),
    alternative = 'two.sided',
    conf.level = 0.95,
    detailed = TRUE) |> 
    dplyr::select(p) |> unlist() |> as.character() |> as.numeric()
}

GO_info_by_term_df2 <- GO_info_by_term_df2 |> 
  dplyr::mutate(adjp = p.adjust(p = GO_info_by_term_df2$pval, method = 'BH'), .after= pval)

GO_info_by_term_df2$binom_adjp = p.adjust(p = GO_info_by_term_df2$binom_pval, method = 'BH')
```

```{r check results, include = T, message = F, warning = F, echo = T}
head(GO_info_by_term_df2 |> dplyr::select(-contains("Gene_IDs")))
```

